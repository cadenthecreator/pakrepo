{
  files = {
    Levels = {
      [ "Level 7.map" ] = "000000444440044444444440000000043334001111114444004334000333000444411444330400400000000044000000033044440044444004400000000004444004440000000044004444110000311000000004403344411004444400224334440330004400444433022433444000000000044443304443344411440044000004400444334441144004400000440031300000000000444440044003330000000000044444003300000004444444404330000330011100444444441433000011001510011333311110050604",
      [ "Level 13.map" ] = "000000000011011000000000000011110301101100441000000012211030010010031100133001220001001001003100113300110001100000100332011330011000110001010000200033000000001000201000001111111112200100010000000111111111110000031300220000000000000000003330000000000022111111000030000111112222222222001000001002222222000000000110001100000000000110001000000000100011330011100110011100110011333000000001001510010000003415050402",
      [ "Level 12.map" ] = "000000220000000000000000000110000000000000022000000144100033333333300001110014410030003333333001000100110033333333000330000100000003334333334333000100011100333333333333300000010001033333000003330001000001003311333333333000000001000011111111133000001100000000111123333000000220010000000000000000001100000000000000000011101441011000024400000003110144102200002220011101132001100000000332001510111020000012060303",
      [ "Level 9.map" ] = "000000000000000000000000000440000001000100000000000022001100000000011044211004400113333211111104420000000011111123333110442111033001100000000011044200013110000000000000004421103011300001111100000442003000330001144411000044211000000001124442110000000010113300100000001003311110111330000000000000331140101111001111111110011111100000000110000011001111400322220000011100000000000234444001101510110002201430020002",
      [ "Level 14.map" ] = "000000010001000000000000011000001111100000000000000003000000000000000040011110110000000000333334001100011000000000023333400001101144444444442333340000110111111111111223334001100011011111111122223400111101101111111111222240000000000000000000000000000011000044444444444444400112200002222222222222220022000000010000000000000000000110001100000000001133113311100010011100100213333334412000001510010021443315030803",
      [ "Level 10.map" ] = "022000022200000222003300000002200000222000002332201220222202422222220444000100000440414000000022202420222022024202222212220042020202000000440000002204242000002222022022220000420102202200002000022022240024222222022212222200024202000220000000000000202420002011022220224422220002020202200022022442222220202222222200000000023300000002200000222222202320202020000222011100020332022222022000201510200022200215050500",
      [ "Level 1.map" ] = "000000000000000000000000011111110011000110011111111111111001122211001111111000000000112221100000000000000110011000110011000000000011000000000001100000110001100000000000110001122000000011000110000000220000000001100011000000000111111100111111100111111111222110011111110011222110000000001100011000000000001111100110001100111110000000000000000000000000000111101110011100111011110000000111001510011100000015000000",
      [ "Level 4.map" ] = "000000000000000000000000001100033330000033330001100330003113211123113000110033044311344444444344011001104130030000000031401100000443113333334443440000110000311400100411300001122000031141121141130000220000003114001004113000000311044344433333311344031011304130000000030031410100000443444444443113440010211000311300000311300131001100033331222133330000000110000000011100000001010011000000001510000000111015050502",
      [ "Level 6.map" ] = "022333223330003331111240002033302333000333111120000333033333333333333110000033000333333300000000000033303033300000144242004443333333300000014424200444033000000330000000000044410011010333330300111004440111331330303330011100444011331103333332001110044400333333000022200111004441003333333311110011100444110303301111111001110144411133330110000000000004442111110000011102211101444221110022001510111110144410060501",
      [ "Level 2.map" ] = "000000000000000000000000000211111111111111111112000014444444444444444444100001444444444444444444410000000000000000000000000001003333333333333333333001200333333333333333333300200000000000000000000000001104444444444444444444011110444444444444444444401111011111111111111111110110000000000000000000000000000130111002220011101300000031000000000000000310002001301110011100111013002200310111001510011103100215050000",
      [ "Level 5.map" ] = "000000000000000000000000000110011001121100110011000011001100110110011001100001100110011211001100110000000000000000000000000000001001033313330133331000304200244444444444444413044420024444444444444444404442002444444444444444444333100133001100001100344400000003000001133003300440004100000000330033001134000401000002220000000000304440100000000000000000220433300110011100000000003011100021001510000000000310050505",
      [ "Level 3.map" ] = "000000000000000000000000000000100000000000000000000000001000002000000000000000001000023132000000000000000020230111032000000000000002300014100032000000000023001101110110032000000230011110141011110032001300000000011100000000331112221111112221111112221101000000000000000000000100104401101133311011044010010110110113331101101101001011000000000000000110100101102330011100332011010010000233001510033200001015050501",
      [ "Level 8.map" ] = "000000000000000000000000003030303010000000000000003030303022000001111111111111111112200000444444444400000000000000000000000001111003330200020333301000100010131004020034440100011110013100040003334010001000001310020400344401000100000333020002033330111100000000000000000000000001111100333000030003010010441000300030203300301010044100030003000313030110004410003333311131133012100441000322231513111301421016050201",
      [ "Level 11.map" ] = "000011002200010110100000002201102222000100100001100220000222204401100033110000000332200440000033330000003333000000000003333000022330110000033000033000022220011000223300022000002222000000222200002200110022330000022223300000111000333300033221330000011144003322113301111022000114400022211044111122220000000002222004401102222000000330022000000001122000330322300000011101111000344032230000001510111100034410030504",
      [ "Level 15.map" ] = "000000000000000000000000000010011001111000020044000011001100313110000300440001100000004440000002000000100011000222000110010000010001033222223301000100000000003333333330000001100220000333333333000000220022001033222223301001100001100110002220001100100011220000002000200000000001122000002200022000111133111111110200000200011110011111111000000000000011111111330000011100000114411111130000001510000011441104040408",
    },
    [ "remote.lua" ] = "---@diagnostic disable: undefined-field\
\
-- Remote contrtolling handler related to Pixel Tank.\
-- Requires: tank.lua\
\
local w_prev, -- Prev specifies whether this key is being pressed in previous tick.\
    s_prev,\
    a_prev,\
    d_prev,\
    space_prev,\
    up_prev,\
    down_prev,\
    left_prev,\
    right_prev,\
    e_prev\
    = false, false, false, false, false, false, false, false, false, false\
\
local pers = peripheral.getNames()\
local redrouters = {}\
local redrouter1\
local redrouter2\
\
for i = 1, #pers do\
    local current = pers[i]\
    if peripheral.getType(current) == \"redrouter\" then\
        table.insert(redrouters, current)\
\
    end\
\
end\
\
if #redrouters == 1 then redrouter1 = peripheral.wrap(redrouters[1])\
elseif #redrouters > 1 then redrouter1, redrouter2 = peripheral.wrap(redrouters[1]), peripheral.wrap(redrouters[2])\
end\
\
local running = true -- Program exits when this signal turns into false.\
\
\
local function quit_event_handler ()\
    os.pullEvent(\"remote_quit\")\
\
end\
\
\
local function remote_event_handler ()\
    while running do\
        if redrouter1 then\
            if w_prev == not redrouter1.getInput('top') then -- Button status on W has been changed.\
                if w_prev then -- If W is in pressed, then switch it.\
                    w_prev = false\
                    os.queueEvent(\"key_up\", 87)\
\
                else\
                    w_prev = true\
                    os.queueEvent(\"key\", 87)\
\
                end\
\
            elseif s_prev == not redrouter1.getInput('bottom') then\
                if s_prev then\
                    s_prev = false\
                    os.queueEvent(\"key_up\", 83)\
\
                else\
                    s_prev = true\
                    os.queueEvent(\"key\", 83)\
\
                end\
\
            elseif a_prev == not redrouter1.getInput('right') then\
                if a_prev then\
                    a_prev = false\
                    os.queueEvent(\"key_up\", 65)\
\
                else\
                    a_prev = true\
                    os.queueEvent(\"key\", 65)\
\
                end\
\
            elseif d_prev == not redrouter1.getInput('left') then\
                if d_prev then\
                    d_prev = false\
                    os.queueEvent(\"key_up\", 68)\
\
                else\
                    d_prev = true\
                    os.queueEvent(\"key\", 68)\
\
                end\
\
            elseif space_prev == not redrouter1.getInput('front') then\
                if space_prev then\
                    space_prev = false\
                    os.queueEvent(\"key_up\", 32)\
\
                else\
                    space_prev = true\
                    os.queueEvent(\"key\", 32)\
\
                end\
\
            end\
        end\
\
        if redrouter2 then\
            if up_prev == not redrouter2.getInput('top') then\
                if up_prev then\
                    up_prev = false\
                    os.queueEvent(\"key_up\", 265)\
\
                else\
                    up_prev = true\
                    os.queueEvent(\"key\", 265)\
\
                end\
\
            elseif down_prev == not redrouter2.getInput('bottom') then\
                if down_prev then\
                    down_prev = false\
                    os.queueEvent(\"key_up\", 264)\
\
                else\
                    down_prev = true\
                    os.queueEvent(\"key\", 264)\
\
                end\
\
            elseif left_prev == not redrouter2.getInput('right') then\
                if left_prev then\
                    left_prev = false\
                    os.queueEvent(\"key_up\", 263)\
\
                else\
                    left_prev = true\
                    os.queueEvent(\"key\", 263)\
\
                end\
\
            elseif right_prev == not redrouter2.getInput('left') then\
                if right_prev then\
                    right_prev = false\
                    os.queueEvent(\"key_up\", 262)\
\
                else\
                    right_prev = true\
                    os.queueEvent(\"key\", 262)\
\
                end\
\
            elseif e_prev == not redrouter2.getInput('front') then\
                if e_prev then\
                    e_prev = false\
                    os.queueEvent(\"key_up\", 69)\
\
                else\
                    e_prev = true\
                    os.queueEvent(\"key\", 69)\
\
                end\
\
            end\
        end\
\
        os.sleep(0.05)\
    end\
end\
\
parallel.waitForAny(remote_event_handler, quit_event_handler)\
\
shell.exit()",
    [ "tank.lua" ] = "---@diagnostic disable: undefined-field, cast-local-type\
\
--PIXEL TANK made by Mr_Octopus_2020\
-- Discord: Mr_Octopus_2020\
\
-- This game can be speaded while assigning its owner.\
\
\
\
-- ============ Setup ============\
\
local version = \"1.6.3\" -- VERSION\
\
local dir = \"/.pakages/pixel_tank\"\
\
local w_pressed,  -- Those are handled by function keyboard_event_handler.\
    a_pressed,\
    s_pressed,\
    d_pressed,\
    space_pressed,\
    up_pressed,\
    down_pressed,\
    left_pressed,\
    right_pressed,\
    e_pressed,\
    enter_pressed\
    = false, false, false, false, false, false, false, false, false, false, false\
\
local player1_pos, player2_pos = {}, {} -- Player tank's position. Used by function checkCollison().\
local spawning_pos = {0, 0} -- Position that is going to spawn a tank.\
\
local player1_score, player2_score = 0, 0\
local total_score = 0\
\
local spawning_enemies, -- Containing all the enemies that is going to spawn.\
    ticking_enemies,\
    deprecated_enemies, -- All Tank objects inside will be ticked.\
    deprecated_but_ticking_enemies -- Contanining tanks that is dead but still have bullets waiting to tick.\
    = {}, {}, {}, {}\
\
local level -- Level blocks data.\
local enemies = {lv1 = 0, lv2 = 0, lv3 = 0, lv4 = 0}\
local player1_defeated_enemies = {lv1 = 0, lv2 = 0, lv3 = 0, lv4 = 0, bonus = 0}\
local player2_defeated_enemies = {lv1 = 0, lv2 = 0, lv3 = 0, lv4 = 0, bonus = 0}\
local current_level = 1 -- Specifies which level is currently loading.\
local target_music -- Used when playing music in parallel API.\
local playing_sound -- Currently playing sounds. Used by Sound_Handler.\
local winned = false -- Used when a stage is completed.\
local time = os.time()\
local paused = false -- Pause the game.\
local freezing = 0 -- If freezing is not 0, enemy tanks cannot move or fire.\
\
local origin_term = term -- This is the original term.\
local resolution = {term.getSize()}\
local screen_center = { -- The position of center-screen point.\
    math.floor(resolution[1] / 2),\
    math.floor(resolution[2] / 2)\
}\
\
\
if resolution[1] < 25 then error(\"This game requires a monitor that widths at least 25 pixels!\", 0) end\
\
if resolution[2] < 19 then error(\"This game requires a monitor that heights at leat 19 pixels!\", 0) end\
\
if resolution[1] < 50 then\
    term.clear()\
    term.setCursorPos(1,1)\
    print(\"This game may be not enjoyable with a monitor that widths less than 50 pixels.\")\
    print()\
    print(\"Press any key to continue :)\")\
    os.pullEvent(\"key\")\
\
end\
\
if not term.isColor() then error(\"This game requires a monitor that supports color!\",0) end\
\
\
local hiscore -- Load High-Score from file.\
if fs.exists(dir .. \"/Hiscore.txt\") then\
    local file = fs.open(dir .. \"/Hiscore.txt\", \"r\")\
    hiscore = tonumber(file.readLine())\
    file.close()\
\
else hiscore = 0\
end\
\
local settings = { -- Game settings. Value table is {Name, Min, Max, Step}.\
    default_HP = {2.0, 0, 9, 1},\
    default_stage = {1.0, 1, 15, 1},\
    enemy_spawn_delay = {2.0, 1, 10, 1},\
    volume = {1.0, 0, 3, 0.1},\
    bonus_chance = {3, 0, 10, 1},\
}\
\
if fs.exists(dir .. \"/Settings.cfg\") then -- Load settings from config.\
    local file = fs.open(dir .. \"/Settings.cfg\", \"r\")\
    local current = 1 -- Currently overwritting value.\
    local values = {} -- All the values the read from file will save here.\
\
    while true do\
        local value = file.readLine()\
\
        if tonumber(value) then -- Read an integer, then load it.\
            value = tonumber(value)\
            table.insert(values, value)\
\
        elseif not(tonumber(value)) then -- If read a non-integer data...\
            if not value then break -- readline() returns nil means the file has come to an end.\
            else table.insert(values, value) -- String formatted data.\
            end\
\
        end\
\
    end\
\
    for key, value in pairs(settings) do -- Overwrite settings with values that read just now.\
        settings[key][1] = values[current]\
        current = current + 1\
\
    end\
\
    file.close()\
end\
\
\
-- Sound effect dumps.\
local sound_select\
local sound_buttonPress\
local sound_tankMove\
local sound_tankFire\
local sound_tankHit\
local sound_tankExplode\
local sound_baseHit\
local sound_experience\
\
\
local speaker = {}\
local env\
local env_string = string.lower(_HOST)\
\
if env_string:find(\"minecraft\") then env = \"minecraft\" -- Minecraft in-game computer.\
    speaker = peripheral.find(\"speaker\")\
\
    if not speaker then\
        speaker = {}\
        function speaker.playSound (sound, volume, pitch) return nil end\
        function speaker.playNote (sound, volume, pitch) return nil end\
\
    end\
\
    sound_select = {\"entity.chicken.step\"}\
    sound_buttonPress = {\"block.dispenser.dispense\"}\
    sound_tankMove = {\"entity.goat.step\"}\
    sound_tankFire = {\"block.dispenser.launch\"}\
    sound_tankHit = {\"entity.player.hurt\"}\
    sound_tankExplode = {\"entity.generic.explode\", 2}\
    sound_baseHit = {\"entity.generic.explode\", 0.8}\
    sound_experience = {\"entity.experience_orb.pickup\"}\
\
elseif env_string:find(\"craftos-\") then -- CraftOS-PC emulator.\
    env = \"craftos-pc\"\
\
    periphemu.remove(\"top\")\
    periphemu.create(\"top\", \"speaker\")\
    speaker = peripheral.wrap(\"top\")\
\
    function speaker.playSound (sound, volume, pitch) return nil end -- Disable speaker.playSound().\
\
    sound_select = {\
        {\"hat\", 24}\
    }\
    sound_buttonPress = {\
        {\"bit\", 16},\
        {\"hat\", 24}\
    }\
    sound_tankMove = nil\
    sound_tankFire = {\
        {\"hat\", 24},\
        {\"basedrum\", 12}\
    }\
    sound_tankHit = {\
        {\"snare\", 24},\
        {\"basedrum\", 4}\
    }\
    sound_tankExplode = {\
        {\"hat\", 24},\
        {\"basedrum\", 24}\
    }\
    sound_baseHit = {\
        {\"hat\", 16},\
        {\"basedrum\", 16}\
    }\
    sound_experience = {\
        {\"pling\", 24}\
    }\
\
elseif env_string:find(\"ccemux\") then -- CCEmux emulator.\
    env = \"ccemux\"\
\
    ccemux.attach(\"top\", \"speaker\")\
    speaker = peripheral.wrap(\"top\")\
\
    function speaker.playSound (sound, volume, pitch) return nil end\
    function speaker.playNote (sound, volume, pitch) return nil end\
\
    term.setBackgroundColor(colors.black)\
    term.clear()\
    term.setCursorPos(1,1)\
\
    term.setTextColor(colors.orange)\
    print(\"Speaker in CCemux is currently not fully tested and may cause problems.\")\
    print()\
    print(\"Sound effects are disabled. For best game experience please use in-game computers.\")\
    print()\
    print()\
    term.setTextColor(colors.lightBlue)\
    print(\"Press any key to continue.\")\
    os.pullEvent(\"key\")\
\
else\
    env = \"unknown\" -- Unknown environment.\
\
    function speaker.playSound (sound, volume, pitch) return nil end -- Disable ALL speaker sound effects.\
    function speaker.playNote (sound, volume, pitch) return nil end\
\
    term.setBackgroundColor(colors.black)\
    term.clear()\
    term.setCursorPos(1,1)\
    print(\"You are running this game on an unknown environment. No sound effects available in this situation.\")\
    print()\
    print(\"Please report this to Mr_Octopus_2020 on pinestore.\")\
    print()\
    print(\"Press any key to continue.\")\
    os.pullEvent(\"key\")\
\
end\
\
\
local pers = peripheral.getNames()\
local redrouters = {}\
local redrouter1\
local redrouter2\
\
for i = 1, #pers do\
    local current = pers[i]\
    if peripheral.getType(current) == \"redrouter\" then\
        table.insert(redrouters, current)\
\
    end\
\
end\
\
if #redrouters == 1 then redrouter1 = peripheral.wrap(redrouters[1])\
elseif #redrouters > 1 then redrouter1, redrouter2 = peripheral.wrap(redrouters[1]), peripheral.wrap(redrouters[2])\
end\
\
local player1_HP, player2_HP = math.floor(settings.default_HP[1]), math.floor(settings.default_HP[1])\
\
\
term.setCursorBlink(false)\
\
\
\
-- ============ Music Dump ============\
--[[\
    every subtable is a note.\
    [1]: (string) instrument.\
    [2]: (integer) pitch.\
    [3]: (int) ticks that will be waited before playing next note. nil means no waiting.\
]]\
\
local music_theme = {\
    {'bit',6},{'bass',6,3},\
    {'bit',8,3},\
    {'bit',9,3},\
    {'bit',6},{'bass',6,3},\
    {'bit',8},{'bass',6,3},\
    {'bit',9},{'bass',6,3},\
\
    {'bit',9},{'bass',9,3},\
    {'bit',11,3},\
    {'bit',13,3},\
    {'bit',9},{'bass',9,3},\
    {'bit',11},{'bass',9,3},\
    {'bit',13},{'bass',9,3},\
\
    {'bit',11},{'bass',11,3},\
    {'bit',13,3},\
    {'bit',15,3},\
    {'bit',11},{'bass',11,3},\
    {'bit',13},{'bass',11,3},\
    {'bit',15},{'bass',11,3},\
\
    {'bit',14},{'bass',14,3},\
    {'bit',16},{'bass',14,3},\
    {'bit',18},{'bass',14,3},\
    {'bit',14},{'bass',16,3},\
    {'bit',16},{'bass',16,3},\
    {'bit',18},{'bass',16,3},\
\
    {'bit',18},{'bass',6},{'bass', 13,10},\
    {'bit',18},{'bass',6},{'bass', 13,3},\
    {'bit',18},{'bass',6},{'bass', 13,3},\
    {'bit',18},{'bass',6},{'bass', 13,3},\
    {'bit',18},{'bass',6},{'bass', 13,3},\
}\
\
local music_pause = {\
    {'bit',10,2},\
    {'bit',12,2},\
    {'bit',17,2},\
    {'bit',19,2},\
    {'bit',14,2},\
}\
\
local music_spawnBonus = {\
    {'bit',13,2},\
    {'bit',13,2},\
    {'bit',13,2},\
    {'bit',13,2},\
    {'bit',15,2},\
    {'bit',13,2},\
    {'bit',15,2},\
    {'bit',17,2},\
    {'bit',18,2},\
}\
\
local music_eatBonus = {\
    {'bit',20,2},\
    {'bit',20,2},\
    {'bit',20,2},\
    {'bit',22,2},\
    {'bit',22,2},\
    {'bit',22,2},\
    {'bit',24,2},\
\
}\
\
local music_eatBonusPlus = {\
    {'bit',15,2},\
    {'bit',19,2},\
    {'bit',15,2},\
    {'bit',10,2},\
    {'bit',15,2},\
    {'bit',19,2},\
    {'bit',24,2},\
    {'bit',22,2},\
    {'bit',22,2},\
    {'bit',22,2},\
\
}\
\
local music_gameover = {\
    {'bit',10,2},\
    {'bit',8,2},\
    {'bit',10,9},\
    {'bit',8,3},\
    {'bit',6,3},\
    {'bit',3,3},\
    {'bit',3,3},\
}\
\
local music_hiscore = {\
    {'bit',20,2},\
    {'bit',17,2},\
    {'bit',13,2},\
    {'bit',20,2},\
    {'bit',17,2},\
    {'bit',13,2},\
    {'bit',20,2},\
    {'bit',20,2},\
    {'bit',20,2},\
    {'bit',20,2},\
    {'bit',20,2},\
    {'bit',20,1},\
\
    {'bit',21,2},\
    {'bit',18,2},\
    {'bit',14,2},\
    {'bit',21,2},\
    {'bit',18,2},\
    {'bit',14,2},\
    {'bit',21,2},\
    {'bit',21,2},\
    {'bit',21,2},\
    {'bit',21,2},\
    {'bit',21,2},\
    {'bit',21,1},\
\
    {'bit',23,2},\
    {'bit',20,2},\
    {'bit',16,2},\
    {'bit',23,2},\
    {'bit',20,2},\
    {'bit',16,2},\
    {'bit',23,2},\
    {'bit',23,2},\
    {'bit',23,2},\
    {'bit',23,2},\
    {'bit',23,2},\
    {'bit',23,2},\
    {'bit',24,2},\
    {'bit',24,2},\
    {'bit',24,2},\
    {'bit',24,2},\
    {'bit',24,2},\
    {'bit',24,2},\
    {'bit',24,2},\
}\
\
\
\
-- ============ Construct Methods ============\
\
local function playMusic (music)\
    --[[\
        Function for read and play sounds.\
        speaker: peripheral.\
        music: (var) Integrated music file.\
        vol: (0.0~1.0) volume for playing.\
    ]]\
\
    if speaker then -- Only play audio when there's available speakers.\
\
        local ins -- Params that will be read from music file.\
        local pitch\
        local time\
\
        for i=1,#music do\
            ins = music[i][1]\
            pitch = music[i][2]\
            time = music[i][3]\
\
            speaker.playNote(ins, settings.volume[1], pitch)\
            if time then os.sleep(time / 20) end -- If time is nil then skip waiting.\
\
        end\
\
    end\
end\
\
\
local function playSoundEffect (sound)\
    local volume, pitch\
\
    if not sound then\
        -- Just do nothing if sound == nil.\
\
    elseif type(sound[1]) == \"table\" then -- Play a list of notes.\
        for i = 1, #sound do\
            local current = sound[i]\
\
            if current[2] then pitch = current[2] else pitch = 12 end\
            if current[3] then volume = current[3] else volume = 1 end\
\
            speaker.playNote(current[1], settings.volume[1] * volume, current[2])\
\
        end\
\
    elseif type(sound[1]) == \"string\" then\
        if sound[3] then volume = sound[3] else volume = 1 end\
        if sound[2] then pitch = sound[2] else pitch = 1 end\
\
        speaker.playSound(sound[1], settings.volume[1] * volume, sound[2])\
\
    end\
\
end\
\
\
local function keyboard_event_handler ()\
    --Function for listening and processing keyboard events.\
\
    local events\
\
    while true do\
        events = {os.pullEvent()} -- Outputs {event name, event parameters*}.\
\
        if events[1] == 'key' then -- key pressed\
            local key = keys.getName(events[2])\
\
            if key == 'w' then w_pressed = true\
            elseif key == 's' then s_pressed = true\
            elseif key == 'a' then a_pressed = true\
            elseif key == 'd' then d_pressed = true\
            elseif key == 'space' then space_pressed = true\
            elseif key == 'up' then up_pressed = true\
            elseif key == 'down' then down_pressed = true\
            elseif key == 'left' then left_pressed = true\
            elseif key == 'right' then right_pressed = true\
            elseif key == 'e' then e_pressed = true\
            elseif key == 'enter' then enter_pressed = true\
            elseif (key == 'rightShift' or key == 'leftShift') and paused then-- If Shift is pressed during pause, then quit.\
                playSoundEffect(sound_buttonPress)\
                winned = false\
\
                break\
            end\
\
        elseif events[1] == 'key_up' then -- key released\
            local key = keys.getName(events[2])\
\
            if key == 'w' then w_pressed = false -- getName() converts keyID into character.\
            elseif key == 's' then s_pressed = false\
            elseif key == 'a' then a_pressed = false\
            elseif key == 'd' then d_pressed = false\
            elseif key == 'space' then space_pressed = false\
            elseif key == 'up' then up_pressed = false\
            elseif key == 'down' then down_pressed = false\
            elseif key == 'left' then left_pressed = false\
            elseif key == 'right' then right_pressed = false\
            elseif key == 'e' then e_pressed = false\
            elseif key == 'enter' then enter_pressed = false\
            end\
\
        end\
\
    end\
end\
\
\
local function drawBackground ()\
    -- Thanks to RamiLego. (Redirection Computercraft Edition)\
    local stars = {\",\", \".\", \"*\", \"Â·\"}\
    local color = {colors.lightGray, colors.gray}\
\
    term.setBackgroundColor(colors.black)\
    for x = 1, resolution[1] do\
        for y = 1, resolution[2] do\
            if math.random(1,10) == 10 then\
                term.setTextColor(color[math.random(1, #color)])\
                term.setCursorPos(x, y)\
                term.write(stars[math.random(1, #stars)])\
\
            end\
        end\
    end\
\
end\
\
\
local function menu (buttons, isSwitchable, defaultIndex)\
    -- Function for switch the term to menu.\
    -- isSwitchable specifies whether buttons can be switched using A and D.\
\
    local selected\
    if defaultIndex then selected = defaultIndex else selected = 1 end\
    local events\
\
    term.setTextColor(colors.white)\
\
    local function btn_reset(delay) -- Reset all the buttons.\
        for i=1,#buttons do\
            local btn = buttons[i] -- Load string.\
            term.setTextColor(colors.white)\
            term.setBackgroundColor(colors.black)\
\
            term.setCursorPos(math.floor(screen_center[1] - #btn[2] / 2) - 1, btn[1]) -- Erase the old button.\
            term.write(string.rep(\" \",#btn[2] + 3))\
\
            term.setCursorPos(math.floor(screen_center[1] - #btn[2] / 2) + 1, btn[1]) -- Write new button in the middle of the screen, with given y pos.\
            term.write(btn[2])\
\
            if delay then os.sleep(delay) end\
\
        end\
\
    end\
\
    if isSwitchable then btn_reset()\
    else btn_reset(0.02)\
    end\
\
    local btn = buttons[selected]\
\
    term.setTextColor(colors.yellow)\
    term.setCursorPos(math.floor(screen_center[1] - #btn[2] / 2) - 1, btn[1])\
    term.write(\"> \" .. btn[2])\
\
    while true do -- Listen to keyboard events.\
        events = {os.pullEvent()}\
\
        if events[1] == 'key' then -- Select menu buttons.\
            events.char = keys.getName(events[2])\
\
            if events.char == \"w\" then -- W.\
                if selected > 1 then -- Avoid overflow while change var \"selected\".\
                    selected = selected - 1\
                    playSoundEffect(sound_select)\
\
                end\
\
            elseif events.char == \"s\" then -- S.\
                if selected < #buttons then\
                    selected = selected + 1\
                    playSoundEffect(sound_select)\
\
                end\
\
            elseif (events[2] == 57\
            or events[2] == 28\
            or events[2] == 257\
            or events[2] == 32)\
            and events.char ~= \"d\"\
            then -- Enter or Space.\
                playSoundEffect(sound_buttonPress)\
\
                return buttons[selected][2], \"confirm\" -- Return button commands\
\
            elseif events.char == \"a\" and isSwitchable then -- A.\
                    playSoundEffect(sound_tankMove)\
\
                    return buttons[selected][2], \"left\", selected\
\
            elseif events.char == \"d\" and isSwitchable then -- D.\
                    playSoundEffect(sound_tankMove)\
\
                    return buttons[selected][2], \"right\", selected\
\
            end\
\
        end\
\
        -- Change the style of menu buttons based on which one is selected.\
        btn_reset()\
\
        btn = buttons[selected]\
\
        term.setTextColor(colors.yellow)\
        term.setCursorPos(math.floor(screen_center[1] - #btn[2] / 2) - 1, btn[1])\
        term.write(\"> \" .. btn[2])\
\
    end\
\
end\
\
\
local function numInput (text, min, max)\
    local input\
\
    term.setBackgroundColor(colors.lightGray)\
    term.clear()\
\
    term.setTextColor(colors.white)\
    term.setCursorPos(screen_center[1] - (#text / 2), screen_center[2] - 1) -- Write in the middle of the screen.\
    term.write(text)\
\
    term.setBackgroundColor(colors.white)\
    term.setTextColor(colors.black)\
    term.setCursorPos(1, screen_center[2] + 1)\
    term.write(string.rep(\" \", resolution[1]))\
    term.setCursorPos(screen_center[1] - (#text / 2), screen_center[2] + 1)\
\
\
    origin_term.setBackgroundColor(colors.lightGray)\
    origin_term.clear()\
\
    origin_term.setTextColor(colors.white)\
    origin_term.setCursorPos(1, 8) -- Write in the middle of the screen.\
    origin_term.write(text)\
\
    repeat\
        origin_term.setBackgroundColor(colors.white)\
        origin_term.setTextColor(colors.black)\
        origin_term.setCursorPos(1, 10)\
        origin_term.write(string.rep(\" \", 200))\
        origin_term.setCursorPos(1, 10)\
        os.sleep(0.1)\
\
        input = tonumber(read())\
\
    until input and input >= min and input <= max -- If player input anything that incorrect, then let them retry.\
\
    return tonumber(input) -- Only take integer.\
\
end\
\
\
local function SettingScreen () -- Settings menu.\
    local last_selected_btn = 1\
\
    term.setBackgroundColor(colors.black)\
    for i = 1, screen_center[2] + 1 do -- Clear the screen.\
        origin_term.scroll(1)\
        term.scroll(2)\
        os.sleep(0.05)\
\
    end\
    drawBackground()\
\
    term.setBackgroundColor(colors.gray)\
    for i = resolution[2] - 2, resolution[2] do\
        term.setCursorPos(1, i)\
        term.write(string.rep(\" \", resolution[1]))\
\
    end\
\
    term.setTextColor(colors.white)\
    term.setCursorPos(1, resolution[2] - 2)\
    term.write(\"Use W/S to select.\")\
    term.setCursorPos(1, resolution[2] - 1)\
    term.write(\"A/D to change value.made\")\
    term.setCursorPos(1, resolution[2])\
    term.write(\"Hit Space to input value manually.\")\
\
    while true do\
        term.setTextColor(colors.lightBlue)\
        term.setBackgroundColor(colors.black)\
\
        local buttons = {{3, \"Back\"}}\
        local y_pos = 5 -- Y position for displaying the button.\
\
        for key, value in pairs(settings) do -- Load buttons from table \"settings\"\
            table.insert(buttons, {y_pos, key})\
            term.setCursorPos(4, y_pos)\
            term.write(value[1] .. \"  \")\
\
            y_pos = y_pos + 2\
\
        end\
\
        local callback, operation, returned_btn = menu(buttons, true, last_selected_btn) -- Display menu.\
        last_selected_btn = returned_btn\
\
        local target = settings[callback] -- Specify the object that is going to be set.\
\
        if callback == \"Back\" and operation == \"confirm\" then break\
\
        else\
            if operation == \"left\" and target[1] > target[2] then\
                target[1] = target[1] - target[4]\
\
                if target[1] < 0.1 then target[1] = 0 end -- Avoid float number crash.\
\
            elseif operation == \"right\" and target[1] < target[3] then target[1] = target[1] + target[4]\
\
            elseif operation == \"confirm\" then\
                local input = numInput(\"Specify \" .. callback .. \" between \"\
                .. target[2] .. \" and \" .. target[3] .. \".\", target[2], target[3])\
\
                target[1] = input\
\
                term.setBackgroundColor(colors.black)\
                term.clear()\
                drawBackground()\
\
            end\
\
        end\
\
    end\
\
    -- Apply settings.\
    player1_HP, player2_HP = math.floor(settings.default_HP[1]), math.floor(settings.default_HP[1])\
\
    -- Dump settings.\
    local file = fs.open(dir .. \"/Settings.cfg\", \"w\")\
\
    for key, value in pairs(settings) do\
        file.writeLine(value[1])\
\
    end\
\
    file.close()\
\
end\
\
\
local function switchscreen (text)\
    term.setBackgroundColor(colors.lightGray)\
\
    for i=1, screen_center[2] + 1 do -- fill the screen.\
        term.setCursorPos(1, i)\
        term.write(string.rep(\" \", resolution[1]))\
\
        term.setCursorPos(1, resolution[2] + 1 - i)\
        term.write(string.rep(\" \", resolution[1]))\
\
        os.sleep(0.05)\
\
    end\
\
    term.setCursorPos(1, screen_center[2])\
    term.write(string.rep(\" \", resolution[1]))\
\
    term.setTextColor(colors.black)\
    term.setCursorPos(screen_center[1] - #text/2 + 1, screen_center[2] + 1) -- Write text in the middle.\
    term.write(text)\
\
end\
\
\
local function getLevelIndex (x,y) return (y-2) * 25 + (x - (screen_center[1] - 13)) end -- Get block position in dumped file by (x,y).\
\
\
local function leveleditor () -- Level editor.\
    local file\
\
    local function getEdit (rawData)\
        local data = {} -- Map data.\
        local selected = 1 -- Currently selected block.\
        local blocks = {'brick', 'steel', 'leave', 'water'} -- Placeable blocks.\
        local colors_block = {colors.brown ,colors.lightGray, colors.lime, colors.blue}\
\
        if not rawData then for i = 1,400 do table.insert(data,i,0) end -- Initialize data.\
\
        else   -- If specified map at start, then load it.\
            -- Convert string-typed level code into table \"data\".\
            for i = 1,#rawData do table.insert(data, i, tonumber(string.sub(rawData, i, i))) end\
\
            for y = 1, 16 do -- Read level.\
                for x = screen_center[1] - 12, screen_center[1] + 12 do\
                    local current = data[(y - 1) * 25 + (x - 12)] -- Currently reading block.\
                    term.setCursorPos(x, y)\
\
                    if current == 0 then -- Air\
                        term.setBackgroundColor(colors.black)\
                        term.write(\" \")\
\
                    elseif current == 1 then -- Brick\
                        term.setBackgroundColor(colors.brown)\
                        term.write(\" \")\
\
                    elseif current == 2 then -- Steel\
                        term.setBackgroundColor(colors.lightGray)\
                        term.write(\" \")\
\
                    elseif current == 3 then -- leave\
                        term.setBackgroundColor(colors.lime)\
                        term.write(\" \")\
\
                    elseif current == 4 then -- Water\
                        term.setBackgroundColor(colors.blue)\
                        term.write(\" \")\
\
                    end\
                end\
            end\
        end\
\
        -- Place base. Actual dump are operated below.\
        term.setCursorPos(screen_center[1], 16)\
        term.setBackgroundColor(colors.black)\
        term.setTextColor(colors.lightGray)\
        term.write(\"&\")\
\
        term.setTextColor(colors.white)\
        term.setBackgroundColor(colors_block[selected])\
        term.setCursorPos(1, resolution[2] - 1)\
        term.write(string.rep(\" \", resolution[1]))\
        term.setCursorPos(1,resolution[2] - 1)\
        term.write(\"Selected block: \" .. blocks[selected])\
\
        repeat\
            local events = {os.pullEvent()}\
\
            if events[1] == 'mouse_scroll' then -- Select block.\
\
                if events[2] == -1 then\
                    if selected < 4 then selected = selected + 1 end\
\
                elseif events[2] == 1 then\
                    if selected > 1 then selected = selected - 1 end\
\
                end\
\
                term.setBackgroundColor(colors_block[selected])\
                term.setTextColor(colors.white)\
                term.setCursorPos(1, resolution[2] - 1)\
                term.write(string.rep(\" \",resolution[1]))\
                term.setCursorPos(1, resolution[2] - 1)\
                term.write(\"Selected block: \" .. blocks[selected])\
\
            elseif (events[1] == 'mouse_drag' or events[1] == 'mouse_click') -- Place block or erase it.\
            and events[3] >= screen_center[1] - 12\
            and events[3] <= screen_center[1] + 12\
            and events[4] >= 1\
            and events[4] <= 16\
            and not (events[3] == screen_center[1] and events[4] == 16)\
            and not (events[3] == screen_center[1] - 12 and events[4] == 1)\
            and not (events[3] == screen_center[1] and events[4] == 1)\
            and not (events[3] == screen_center[1] + 12 and events[4] == 1)\
            then\
\
                local blockIndex -- The index of the block that is going to be write in the file.\
\
                if events[2] == 1 then -- Left mouse button means to place.\
                    blockIndex = selected\
\
                elseif events[2] == 2 then -- Right means to erase it.\
                    blockIndex = 0\
\
                end\
\
                local index = (events[4] - 1) * 25 + (events[3] - 12)\
                data[index] = blockIndex -- Write block to data.\
\
                if blockIndex ~= 0 then term.setBackgroundColor(colors_block[blockIndex]) -- If this is not an erase operation...\
                else term.setBackgroundColor(colors.black)\
                end\
\
                term.setCursorPos(events[3],events[4])\
                term.write(\" \")\
\
            end\
\
        until events[1] == 'key' and (events[2] == 257 or events[2] == 28) -- Exit edit mode when ENTER pressed.\
\
        -- Convert data into level code.\
        data[388] = 5 -- Place base at index 388, which is the bottom of the map.\
        local texts = {\"Specify amount of Lv1 enemy in the stage(0-99)\",\
        \"Specify amount of Lv2 enemy in the stage(0-99)\",\
        \"Specify amount of Lv3 enemy in the stage(0-99)\",\
        \"Specify amount of Lv4 enemy in the stage(0-99)\",\
        }\
\
        for i = 1, #texts do -- Ask for players about the amount of the enemies in the stage.\
            local amount = string.sub(tostring(numInput(texts[i], 0, 99)),1,2)\
            if #amount == 1 then -- If their input lengths 1...\
                data[399 + i * 2] = 0\
                data[400 + i * 2] = amount\
\
            else -- Or they lengths 2...\
                data[399 + i * 2] = string.sub(amount,1,1)\
                data[400 + i * 2] = string.sub(amount,2,2)\
\
            end\
\
        end\
\
\
        local editedLevel = \"\"\
        for i = 1,#data do editedLevel = editedLevel .. tostring(data[i]) end\
\
        return editedLevel -- Return level code (String type).\
\
    end\
\
    for i = 1, screen_center[2] + 1 do -- Clear the screen.\
        term.scroll(2)\
        os.sleep(0.05)\
\
    end\
    drawBackground()\
\
    local save_files = {\
        \"Level 1.map\",\
        \"Level 2.map\",\
        \"Level 3.map\",\
        \"Level 4.map\",\
        \"Level 5.map\",\
        \"Level 6.map\",\
        \"Level 7.map\",\
        \"Level 8.map\",\
        \"Level 9.map\",\
        \"Level 10.map\",\
        \"Level 11.map\",\
        \"Level 12.map\",\
        \"Level 13.map\",\
        \"Level 14.map\",\
        \"Level 15.map\",\
    }\
\
    while true do\
        local callback = menu({\
            {8,\"Edit level\"},\
            {10,\"Delete level\"},\
            {12,\"Back\"},\
        })\
\
        if callback == \"Edit level\" then\
            term.setBackgroundColor(colors.black)\
            for i = 1, screen_center[2] + 1 do -- Clear the screen.\
                term.scroll(2)\
                os.sleep(0.05)\
\
            end\
            drawBackground()\
\
            for i = 1,#save_files do\
                if fs.exists(dir .. \"/Levels/\" .. save_files[i]) then\
                    term.setCursorPos(screen_center[1] - 10, i + 1)\
                    term.setBackgroundColor(colors.lime)\
                    term.write(\"  \")\
\
                end\
            end\
\
            local slot = menu({ -- Let user select a slot.\
                {2,\"Level 1\"},\
                {3,\"Level 2\"},\
                {4,\"Level 3\"},\
                {5,\"Level 4\"},\
                {6,\"Level 5\"},\
                {7,\"Level 6\"},\
                {8,\"Level 7\"},\
                {9,\"Level 8\"},\
                {10,\"Level 9\"},\
                {11,\"Level 10\"},\
                {12,\"Level 11\"},\
                {13,\"Level 12\"},\
                {14,\"Level 13\"},\
                {15,\"Level 14\"},\
                {16,\"Level 15\"},\
                {18,\"Back\"},\
            })\
\
            if slot ~= \"Back\" then\
                local slot_dir = dir .. \"/Levels/\" .. slot .. \".map\"\
\
                term.setBackgroundColor(colors.gray)\
                term.clear()\
\
                term.setCursorPos(1, resolution[2])\
                term.setTextColor(colors.white)\
                term.write(\"Left/Right mouse to draw/erase. ENTER to save.\")\
\
                term.setBackgroundColor(colors.black) -- Split up an area to draw.\
                for i=1,16 do\
                    term.setCursorPos(screen_center[1] - 12,i)\
                    term.write(string.rep(\" \",25))\
                end\
\
                -- Open and operate specified file.\
                local editedLevel\
\
                if fs.exists(slot_dir) then -- If there's already a level file ,in the slot, then load it first.\
                    file = fs.open(slot_dir, \"r\")\
                    local dataInFile = file.readAll()\
                    file.close()\
\
                    file = fs.open(slot_dir, \"w\")\
                    editedLevel = getEdit(dataInFile)\
\
                else\
                    file = fs.open(slot_dir, \"w\")\
                    editedLevel = getEdit()\
\
                end\
\
                file.write(editedLevel) -- Write level data into file.\
                file.close()\
\
            end\
\
        elseif callback == \"Delete level\" then\
            term.setBackgroundColor(colors.black)\
            for i = 1, screen_center[2] + 1 do -- Clear the screen.\
                term.scroll(2)\
                os.sleep(0.05)\
\
            end\
            drawBackground()\
\
            for i = 1,#save_files do\
                if fs.exists(dir .. \"/Levels/\" .. save_files[i]) then\
                    term.setCursorPos(screen_center[1] - 10, i + 1)\
                    term.setBackgroundColor(colors.lime)\
                    term.write(\"  \")\
\
                end\
            end\
\
            local slot = menu({ -- Let user select a slot.\
                {2,\"Level 1\"},\
                {3,\"Level 2\"},\
                {4,\"Level 3\"},\
                {5,\"Level 4\"},\
                {6,\"Level 5\"},\
                {7,\"Level 6\"},\
                {8,\"Level 7\"},\
                {9,\"Level 8\"},\
                {10,\"Level 9\"},\
                {11,\"Level 10\"},\
                {12,\"Level 11\"},\
                {13,\"Level 12\"},\
                {14,\"Level 13\"},\
                {15,\"Level 14\"},\
                {16,\"Level 15\"},\
                {18,\"Back\"},\
            })\
\
            if slot ~= \"back\" then\
                local slot_dir = dir .. \"/Levels/\" .. slot .. \".map\"\
                pcall(fs.delete,slot_dir) -- Avoid crashing when file doesn't exist.\
\
            end\
\
        else break\
\
        end\
\
        term.setBackgroundColor(colors.black)\
        for i = 1, screen_center[2] + 1 do -- Clear the screen.\
            term.scroll(2)\
            os.sleep(0.05)\
\
        end\
\
        drawBackground()\
    end\
\
end\
\
\
local function readlevel (filename) -- Load level profile.\
    level = {} -- Reset current loaded level.\
    local current -- Currently reading data.\
    local file = fs.open(dir .. \"/Levels/\" .. filename, \"r\")\
\
    if not file then return false end\
\
    local data = file.readAll()\
    file.close()\
\
    if #data ~= 408 then return false end\
\
    for i=1,400 do -- Load blocks.\
        current = tonumber(string.sub(data,i,i)) -- Get data on position [i].\
        if current == 0 then table.insert(level,\"air\")\
        elseif current == 1 then table.insert(level,\"brick\")\
        elseif current == 2 then table.insert(level,\"steel\")\
        elseif current == 3 then table.insert(level,\"leave\")\
        elseif current == 4 then table.insert(level,\"water\")\
        elseif current == 5 then table.insert(level,\"base\")\
        end\
\
    end\
\
    enemies.lv1 = string.sub(data,401,402) -- Enemies.\
    enemies.lv2 = string.sub(data,403,404)\
    enemies.lv3 = string.sub(data,405,406)\
    enemies.lv4 = string.sub(data,407,408)\
\
    return true\
\
end\
\
\
local function loadlevel () -- Render screen from variable \"level\".\
    local current -- Currently processing block.\
    os.sleep(1)\
\
    term.setBackgroundColor(colors.gray) -- Fill screen with gray.\
    for i = 1, resolution[2] - 2 do\
        term.setCursorPos(1, i)\
        term.write(string.rep(\" \", resolution[1]))\
        os.sleep(0.05)\
\
    end\
\
    term.setBackgroundColor(colors.lightGray) -- A line of light gray.\
    term.setCursorPos(1, resolution[1] - 1)\
    term.write(string.rep(\" \", resolution[1]))\
    os.sleep(0.05)\
\
    term.setBackgroundColor(colors.blue) -- A line of white.\
    term.setCursorPos(1, resolution[2])\
    term.write(string.rep(\" \", resolution[1]))\
    os.sleep(0.05)\
\
\
    term.setBackgroundColor(colors.black) -- Split a black gameplay window.\
    for i=2,17 do\
        term.setCursorPos(screen_center[1] - 12, i)\
        term.write(string.rep(\" \", 25))\
        os.sleep(0.05)\
\
    end\
\
    for y = 2, 17 do -- Load level one line per time.\
        for x = screen_center[1] - 12, screen_center[1] + 12 do\
            current = level[getLevelIndex(x,y)] -- Read data from var \"level\".\
\
            -- Render level.\
            term.setCursorPos(x,y)\
            if current == 'air' then -- Air\
                term.setBackgroundColor(colors.black)\
                term.write(\" \")\
\
            elseif current == 'brick' then -- Brick\
                term.setBackgroundColor(colors.brown)\
                term.write(\" \")\
\
            elseif current == 'steel' then -- Steel\
                term.setBackgroundColor(colors.lightGray)\
                term.write(\" \")\
\
            elseif current == 'leave' then -- leave\
                term.setBackgroundColor(colors.lime)\
                term.write(\" \")\
\
            elseif current == 'water' then -- Water\
                term.setBackgroundColor(colors.blue)\
                term.write(\" \")\
\
            elseif current == 'base' then -- Base\
                term.setBackgroundColor(colors.black)\
                term.setTextColor(colors.lightGray)\
                term.write(\"&\")\
\
            end\
\
        end\
        os.sleep(0.05)\
\
    end\
\
end\
\
\
local function removeblock (x,y) -- Function for removing a block from map.\
    term.setCursorPos(x,y)\
    term.setBackgroundColor(colors.black)\
    term.write(\" \") -- Render air.\
\
    level[getLevelIndex(x,y)] = 'air' -- Delete it from level data.\
\
    speaker.playNote(\"basedrum\", settings.volume[1], 1)\
    return true\
\
end\
\
\
local function checkCollison (x, y) -- Check if given position presents a tank.\
    if x == player1_pos[1] and y == player1_pos[2] then return 'player1'\
    elseif x == player2_pos[1] and y == player2_pos[2] then return 'player2'\
    end\
\
    if x == spawning_pos[1] and y == spawning_pos[2] then return 'spawn' end\
\
    for i = 1,#ticking_enemies do\
        local enemy_pos = {ticking_enemies[i]:getPos()}\
\
        if x == enemy_pos[1] and y == enemy_pos[2] then return i end -- Return the index of the enemy tank.\
\
    end\
\
    return false\
end\
\
\
\
local Bullet = {}\
function Bullet:__init(facing, owner, isCrusher) -- Method for creating new bullet object.\
    self = {\
        x = 1,\
        y = 1,\
        facing = facing,\
        last_move = time, -- Last move time.\
        owner = owner\
    }\
\
    if isCrusher then self.crusher = true\
    else self.crusher = false\
    end\
\
    setmetatable(self, {__index = Bullet})\
\
    return self\
\
end\
\
function Bullet:show () -- Render the bullet.\
    term.setCursorPos(self.x, self.y)\
    term.setTextColor(colors.white)\
\
    local blocktype = level[getLevelIndex(self.x, self.y)] -- Get block type where the bullet is.\
    if blocktype == 'air' then\
        term.setBackgroundColor(colors.black)\
        term.write('Â·')\
\
    elseif blocktype == 'leave' then -- if the tank is in leaves...\
        term.setBackgroundColor(colors.lime)\
        term.write(\" \")\
\
    elseif blocktype == 'water' then -- if the tank is in leaves...\
        term.setBackgroundColor(colors.blue)\
        term.write(\"Â·\")\
\
    end\
\
end\
\
function Bullet:hide () -- hide the bullet.\
    term.setCursorPos(self.x, self.y)\
\
    local blocktype = level[getLevelIndex(self.x, self.y)]\
    if blocktype == 'air' then\
        term.setBackgroundColor(colors.black)\
\
    elseif blocktype == 'brick' then\
        term.setBackgroundColor(colors.brown)\
\
    elseif blocktype == 'steel' then\
        term.setBackgroundColor(colors.lightGray)\
\
    elseif blocktype == 'leave' then\
        term.setBackgroundColor(colors.lime)\
\
    elseif blocktype == 'water' then\
        term.setBackgroundColor(colors.blue)\
\
    end\
\
    term.write(\" \")\
\
end\
\
function Bullet:setPos (x,y)\
    self.x, self.y = x,y\
\
end\
\
function Bullet:tick ()\
    local target_x = self.x -- The position that bullet is going to.\
    local target_y = self.y\
\
    self.last_move = time\
\
    if self.facing == 'up' then target_y = target_y - 1 -- Predict position that will be moved to.\
    elseif self.facing == 'down' then target_y = target_y + 1\
    elseif self.facing == 'left' then target_x = target_x - 1\
    elseif self.facing == 'right' then target_x = target_x + 1\
    end\
\
    local collision = checkCollison(target_x, target_y) or checkCollison(self.x, self.y)\
    local target_block = level[getLevelIndex(target_x, target_y)]\
\
    if (target_block == 'air'\
    or target_block == 'leave'\
    or target_block == 'water')\
    and not collision\
    and (target_x >= screen_center[1] - 12 and target_x <= screen_center[1] + 12)\
    and (target_y >= 2 and target_y <= 17)\
    then -- Only move if target position is inside the map and hit air or acceptable blocks.\
        self:hide()\
        self:setPos(target_x, target_y)\
        self:show()\
\
    elseif target_block == 'brick' -- Hit on brick.\
    and (target_x >= (screen_center[1] - 12) and target_x <= (screen_center[1] + 12))\
    and (target_y >= 2 and target_y <= 17)\
    then\
        removeblock(target_x, target_y)\
        self:hide()\
        speaker.playNote('bit', settings.volume[1], 24)\
        return false\
\
    elseif target_block == 'steel' -- Hit on steel. Brake it if this bullet is fired by a crusher tank.\
    and (target_x >= (screen_center[1] - 12) and target_x <= (screen_center[1] + 12))\
    and (target_y >= 2 and target_y <= 17)\
    and self.crusher\
    then\
        removeblock(target_x, target_y)\
        self:hide()\
        speaker.playNote('bit', settings.volume[1], 24)\
        return false\
\
    elseif target_block == 'base' then -- Hit on base.\
        os.queueEvent(\"hit\", \"base\")\
        self:hide()\
        return false\
\
    elseif (target_block == 'HP'\
    or target_block == \"upgrade\"\
    or target_block == \"godtime\"\
    or target_block == \"bomb\"\
    or target_block == \"freeze\")\
    and (target_x >= (screen_center[1] - 12) and target_x <= (screen_center[1] + 12))\
    and (target_y >= 2 and target_y <= 17)\
    then -- Hit on bonuses.\
        os.queueEvent(\"hit\", target_block, self.owner, {target_x, target_y})\
        self:hide()\
        return false\
\
    elseif collision then -- Hit a tank.\
        if type(collision) == \"number\" then -- Return number means it hits on an AI enemy tank.\
            if self.owner == 'enemy' then -- The enemy is hitting its friend!\
                self:hide()\
                return false\
\
            else\
                os.queueEvent(\"hit\", collision, self.owner)\
                self:hide()\
                return false\
\
            end\
\
        else -- Not number means it hits on a player.\
            if collision == self.owner then -- It hits the tank who launches it!\
                self:hide()\
                self:setPos(target_x, target_y)\
                self:show()\
\
            elseif collision ~= self.owner then -- Hit an enemy. (Or maybe an ally :P )\
                os.queueEvent(\"hit\", collision)\
                self:hide()\
                return false\
\
            end\
\
        end\
\
    else -- Hit on something that cannot be braked.\
        self:hide()\
        speaker.playNote('bit', settings.volume[1], 24)\
        return false\
\
    end\
\
    return true -- Tell game to keep ticking this bullet object.\
\
end\
\
setmetatable(Bullet, {__call = Bullet.__init})\
\
\
local Tank = {} -- Class: Tank\
\
function Tank:__init(model, color) -- Method for creating new tank object.\
    self = {\
        hp = 1,\
        speed = 4,\
        survive = true,\
        godtime = 0, -- Ticks left for god mode.\
\
        x = 1,\
        y = 1,\
        facing = 'up',\
        model = model,\
        crusher = false, -- Decide whether this tank can brake steel blocks.\
        boat = false, -- Decide whether this tank can run on water.\
\
        tick_cooldown = 5, -- Cooldown when tank is blocked and avoid crashing game.\
        last_move = 0, -- Last moved time.\
        last_move_direction = 'down', -- Last moved direction of an AI tank.\
        last_fire = 0, -- Last fired time.\
\
        ticking_bullets = {},\
        deprecated_bullets = {},\
    }\
\
    if model == 1 then\
        self.color = colors.white\
        self.firingspeed = 10 -- Time in ticks that a tank must wait until next fire.\
\
    elseif model == 2 then\
        self.color = colors.orange\
        self.firingspeed = 5\
\
    elseif model == 3 then\
        self.color = colors.magenta\
        self.speed = 2\
        self.firingspeed = 20\
\
    elseif model == 4 then\
        self.color = colors.red\
        self.hp = 4\
        self.firingspeed = 10\
\
    end\
\
    if color then self.color = color end\
\
    setmetatable(self, {__index = Tank})\
\
    return self\
\
end\
\
function Tank:setGodtime (godtime) self.godtime = godtime end\
\
function Tank:tickGodtime ()\
    if self.godtime > 0 then self.godtime = self.godtime - 1 end\
\
end\
\
function Tank:isGodtime()\
    if self.godtime <= 0 then return false\
    else return true\
    end\
\
end\
\
function Tank:getHP () return self.hp end\
\
function Tank:addHP () self.hp = self.hp + 1 end\
\
function Tank:removeHP (value)\
    self.hp = self.hp - value\
    playSoundEffect(sound_tankHit)\
\
end\
\
function Tank:getModel () return self.model end\
\
function Tank:upgrade ()\
    if self.model >= 1 and self.model <= 4 then\
        self.model = 5\
        self.firingspeed = 8\
\
    elseif self.model == 5 then\
        self.model = 6\
        self.speed = 3\
\
    elseif self.model == 6 then\
        self.model = 7\
        self.crusher = true\
\
    elseif self.model == 7 then\
        self.model = 8\
        self.boat = true\
\
    end\
\
end\
\
function Tank:isCrusher ()\
    if self.crusher then return true\
    else return false\
    end\
\
end\
\
function Tank:isBoat()\
    if self.boat then return true\
    else return false\
    end\
\
end\
\
function Tank:show () -- Render the tank.\
    term.setCursorPos(self.x, self.y)\
    term.setTextColor(self.color)\
\
    local blocktype = level[getLevelIndex(self.x, self.y)] -- Get block type where the tank is.\
    if blocktype == 'air' then\
        if self.godtime ~= 0 then term.setBackgroundColor(colors.gray)\
        else term.setBackgroundColor(colors.black)\
        end\
\
        if self.facing == 'up' then term.write(\"^\")\
        elseif self.facing == 'down' then term.write(\"v\")\
        elseif self.facing == 'left' then term.write(\"<\")\
        else term.write(\">\")\
        end\
\
    elseif blocktype == 'water' then\
        if self.godtime ~= 0 then term.setBackgroundColor(colors.gray)\
        else term.setBackgroundColor(colors.blue)\
        end\
\
        if self.facing == 'up' then term.write(\"^\")\
        elseif self.facing == 'down' then term.write(\"v\")\
        elseif self.facing == 'left' then term.write(\"<\")\
        else term.write(\">\")\
        end\
\
    elseif blocktype == 'leave' then -- if the tank is in leaves...\
        term.setBackgroundColor(colors.green)\
        term.write(\" \")\
\
    end\
\
end\
\
function Tank:hide () -- hide the tank.\
    term.setCursorPos(self.x, self.y)\
\
    local blocktype = level[getLevelIndex(self.x, self.y)]\
    if blocktype == 'air' then\
        term.setBackgroundColor(colors.black)\
\
    elseif blocktype == 'brick' then\
        term.setBackgroundColor(colors.brown)\
\
    elseif blocktype == 'steel' then\
        term.setBackgroundColor(colors.lightGray)\
\
    elseif blocktype == 'leave' then\
        term.setBackgroundColor(colors.lime)\
\
    elseif blocktype == 'water' then\
        term.setBackgroundColor(colors.blue)\
\
    end\
\
    term.write(\" \")\
\
end\
\
function Tank:kill ()\
    playSoundEffect(sound_tankExplode)\
    self:hide()\
    self:setPos(1,1)\
    self.survive = false\
\
end\
\
function Tank:born (x, y, hp, godtime)\
    if not godtime then godtime = 0 end\
\
    self:setPos(x, y)\
\
    self.godtime = godtime\
    self.firingspeed = 10\
    self.speed = 4\
    self.crusher = false\
    self.boat = false\
    self.hp = hp\
    self.model = 1\
    self.survive = true\
    self:show()\
\
end\
\
function Tank:isSurvive () return self.survive end\
\
function Tank:getPos () return self.x, self.y end\
\
function Tank:setPos (x,y) self.x, self.y = x,y end\
\
function Tank:move (direction)\
    local target_x = self.x -- The position that tank is going to.\
    local target_y = self.y\
\
    if self.survive then -- Only execute codes below if tank is not dead.\
\
        if direction == 'up' then self.facing = 'up' target_y = self.y - 1 -- Predict position that will be moved to.\
        elseif direction == 'down' then self.facing = 'down' target_y = target_y + 1\
        elseif direction == 'left' then self.facing = 'left' target_x = target_x - 1\
        elseif direction == 'right' then self.facing = 'right' target_x = target_x + 1\
        end\
        self:show()\
\
        if math.abs(time - self.last_move) >= self.speed / 1000 then -- Only execute codes below if enouth yield is done after last move.\
            local target_block = level[getLevelIndex(target_x, target_y)]\
\
            if (target_block == 'air'\
            or target_block == 'leave'\
            or (target_block == 'water' and self.boat))\
            and not checkCollison(target_x, target_y)\
            and (target_x >= screen_center[1] - 12 and target_x <= screen_center[1] + 12)\
            and (target_y >= 2 and target_y <= 17)\
            then -- Only move if target position is inside the map and not in a brick or something.\
                self.last_move = time\
                self:hide()\
                self:setPos(target_x, target_y)\
                self:show()\
                playSoundEffect(sound_tankMove)\
                return true\
\
            end\
\
        end\
\
    end\
\
    return false\
end\
\
function Tank:fire (owner)\
    local target_x = self.x\
    local target_y = self.y\
    if not owner then owner = 'enemy' end\
\
    -- Only fire when there's enouth yield after last fire, and isn't dead.\
    if self.survive and (math.abs(time - self.last_fire) >= self.firingspeed / 1000) then\
        self.last_fire = time\
\
        if self.facing == 'up' then target_y = target_y - 1 -- Predict position that will be fired at.\
        elseif self.facing == 'down' then target_y = target_y + 1\
        elseif self.facing == 'left' then target_x = target_x - 1\
        elseif self.facing == 'right' then target_x = target_x + 1\
        end\
\
        local collision = checkCollison(target_x , target_y)\
        local target_block = level[getLevelIndex(target_x, target_y)]\
\
        if (target_block == 'air'\
        or target_block == 'leave'\
        or target_block == 'water')\
        and not collision\
        and (target_x >= (screen_center[1] - 12) and target_x <= (screen_center[1] + 12))\
        and (target_y >= 2 and target_y <= 17)\
        then -- Only fire if there's enough space in front.\
            local obj = Bullet(self.facing, owner, self.crusher) -- Create a bullet in front.\
\
            obj:setPos(target_x, target_y)\
            obj:show()\
\
            table.insert(self.ticking_bullets,obj)\
            playSoundEffect(sound_tankFire)\
            return true\
\
        elseif target_block == 'brick'\
        and (target_x >= (screen_center[1] - 12) and target_x <= (screen_center[1] + 12))\
        and (target_y >= 2 and target_y <= 17)\
        then\
            removeblock(target_x, target_y)\
            playSoundEffect(sound_tankFire)\
            speaker.playNote('bit', settings.volume[1], 24)\
\
        elseif target_block == 'steel'\
        and (target_x >= (screen_center[1] - 12) and target_x <= (screen_center[1] + 12))\
        and (target_y >= 2 and target_y <= 17)\
        and self.crusher\
        then\
            removeblock(target_x, target_y)\
            playSoundEffect(sound_tankFire)\
            speaker.playNote('bit', settings.volume[1], 24)\
\
        elseif target_block == 'base' then\
            os.queueEvent('hit', 'base')\
\
        elseif target_block == 'HP'\
        or target_block == 'upgrade'\
        or target_block == \"godtime\"\
        or target_block == \"bomb\"\
        or target_block == \"freeze\"\
        then\
            os.queueEvent('hit', target_block, owner, {target_x, target_y})\
\
        elseif collision then\
            if not (owner == \"enemy\" and type(collision) == \"number\") then -- Avoid enemy tank fire on its ally.\
                os.queueEvent('hit', collision, owner)\
                playSoundEffect(sound_tankFire)\
\
            end\
\
        end\
\
    end\
\
    return false\
end\
\
function Tank:clearBullets () self.ticking_bullets, self.deprecated_bullets = {}, {} end\
\
-- Returen if this tank object still have some bullets waiting to be ticked...\
function Tank:stillBulletsTicking () return #self.ticking_bullets ~= 0 and true or false end\
\
function Tank:findPath () -- Find a direction to move.\
    local direction\
    local tries = 0\
\
    repeat\
        local select = math.random(1,10) -- Randomly choose a direction to move.\
\
        if select <= 3 then direction = 'down' -- 30%\
        elseif select <= 6 then direction = 'left' -- 30%\
        elseif select <= 9 then direction = 'right' -- 30%\
        else direction = 'up' -- 10%\
        end\
\
        local success = self:move(direction)\
\
        tries = tries + 1\
\
        if tries >= 10 then return false end\
\
    until success\
\
    return direction\
end\
\
function Tank:tickBullets ()\
    for i=1,#self.ticking_bullets do -- Tick bullets.\
        if not self.ticking_bullets[i]:tick() then -- If the bullet returned false, which it should disappear...\
            table.insert(self.deprecated_bullets, i) -- Mark those Bullet objects as deprecated.\
\
        end\
\
    end\
\
    for j = 1, #self.deprecated_bullets do -- Remove wasted bullets.\
        table.remove(self.ticking_bullets, self.deprecated_bullets[j])\
\
    end\
    self.deprecated_bullets = {}\
\
end\
\
function Tank:tick ()\
    local direction\
\
    self:tickBullets()\
\
    if self.tick_cooldown <= 0 and freezing == 0 then\
        local choice = math.random(1,50)\
\
        if choice == 1 then -- Find new path.\
            direction = self:findPath()\
            if not direction then self.tick_cooldown = 20\
            else self.last_move_direction = direction\
            end\
\
        elseif choice <= 30 then -- Keep moving.\
            -- Try to repeat last move.\
            if math.abs(time - self.last_move) >= self.speed / 1000 then -- Only move if enouth yield.\
                if not self:move(self.last_move_direction) then -- If failed...\
                    if math.random(1,10) == 10 then -- 10% chance to activate finding new path.\
                        direction = self:findPath()\
                        if not direction then self.tick_cooldown = 20\
                        else self.last_move_direction = direction\
                        end\
\
                    end\
\
                end\
            end\
\
        -- Also 40% chance to do nothing.\
        end\
\
        if math.random(1,15) == 1 then self:fire() end -- 7% chace to fire.\
\
    else self.tick_cooldown = self.tick_cooldown - 1\
\
    end\
end\
\
setmetatable(Tank, {__call = Tank.__init}) -- call __init__ when create new object.\
\
\
\
-- ============ MAIN initialization ============\
\
local player1, player2\
\
\
local function sound_Handler () -- Play sounds while gaming.\
    while true do\
        if playing_sound then\
            playMusic(playing_sound)\
            playing_sound = nil\
\
        end\
\
        os.sleep(0.05)\
    end\
end\
\
\
local function spawnEnemy(model, pos)\
    local spawned = Tank(model)\
\
    table.insert(spawning_enemies, {spawned, 20, pos}) -- Add this tank to the end of \"spawning_enemies\".\
\
end\
\
\
local function playMusic_parallel () playMusic(target_music) end\
\
\
local function gameover ()\
    term.setBackgroundColor(colors.black)\
    for i = 1, resolution[2] do\
        term.scroll(1)\
        os.sleep(0.05)\
\
    end -- Clear the screen.\
    drawBackground()\
\
    term.setTextColor(colors.yellow)\
    term.setCursorPos(screen_center[1] - 3,3)\
    term.write(\"Stage \" .. current_level)\
\
    term.setTextColor(colors.lightGray)\
    term.setCursorPos(screen_center[1] - 4,5)\
    term.write(\"P1\")\
\
    term.setCursorPos(screen_center[1] + 2,5)\
    term.write(\"P2\")\
\
    term.setCursorPos(screen_center[1] - 9,7)\
    term.write(\"Lv1\")\
\
    term.setCursorPos(screen_center[1] - 9,8)\
    term.write(\"Lv2\")\
\
    term.setCursorPos(screen_center[1] - 9,9)\
    term.write(\"Lv3\")\
\
    term.setCursorPos(screen_center[1] - 9,10)\
    term.write(\"Lv4\")\
\
    term.setCursorPos(screen_center[1] - 11,11)\
    term.write(\"Bonus\")\
\
    term.setCursorPos(screen_center[1] - 11,12)\
    term.setTextColor(colors.white)\
    term.write(string.rep(\"-\", 22))\
\
    term.setCursorPos(screen_center[1] - 5,14)\
    term.write(\"TOTAL \")\
    term.setTextColor(colors.yellow)\
    term.write(total_score)\
\
    os.sleep(0.8)\
\
    -- Print Player1 scores.\
    term.setTextColor(colors.white)\
\
    -- Scores that is going to be printed. The second element specifies how much score this type of enemy worth.\
    local score_lists = {\
        {player1_defeated_enemies.lv1, 100},\
        {player1_defeated_enemies.lv2, 200},\
        {player1_defeated_enemies.lv3, 250},\
        {player1_defeated_enemies.lv4, 400},\
        {player1_defeated_enemies.bonus, 500},\
    }\
    for i = 1, #score_lists do -- Print scores.\
        term.setCursorPos(screen_center[1] - 4, 6 + i)\
        term.setTextColor(colors.white)\
        term.write(0)\
\
        for j = 1, score_lists[i][1] do\
            term.setCursorPos(screen_center[1] - 4, 6 + i)\
            term.setTextColor(colors.white)\
            term.write(j)\
\
            total_score = total_score + score_lists[i][2]\
\
            term.setCursorPos(screen_center[1] - 5,14)\
            term.write(\"TOTAL \")\
            term.setTextColor(colors.yellow)\
            term.write(total_score)\
\
            speaker.playNote('bit', settings.volume[1], 16)\
            os.sleep(0.1)\
\
        end\
\
        os.sleep(0.5)\
    end\
\
    -- Print Player2 scores.\
    score_lists = {\
        {player2_defeated_enemies.lv1, 100},\
        {player2_defeated_enemies.lv2, 200},\
        {player2_defeated_enemies.lv3, 250},\
        {player2_defeated_enemies.lv4, 400},\
        {player2_defeated_enemies.bonus, 500},\
    }\
    if player2 then\
        for i = 1, #score_lists do -- Print scores.\
            term.setCursorPos(screen_center[1] + 2, 6 + i)\
            term.setTextColor(colors.white)\
            term.write(0)\
\
            for j = 1, score_lists[i][1] do\
                term.setCursorPos(screen_center[1] + 2, 6 + i)\
                term.setTextColor(colors.white)\
                term.write(j)\
\
                total_score = total_score + score_lists[i][2]\
\
                term.setCursorPos(screen_center[1] - 5,14)\
                term.write(\"TOTAL \")\
                term.setTextColor(colors.yellow)\
                term.write(total_score)\
\
                speaker.playNote('bit', settings.volume[1], 16)\
                os.sleep(0.1)\
\
            end\
\
            os.sleep(0.5)\
        end\
    end\
\
    os.sleep(1)\
\
    if winned then\
        term.setTextColor(colors.lime)\
        term.setCursorPos(screen_center[1] - 4,16)\
        term.write(\"YOU WIN!\")\
        playSoundEffect(sound_experience)\
\
    else\
        term.setTextColor(colors.orange)\
        term.setCursorPos(screen_center[1] - 5,16)\
        term.write(\"GAME OVER!\")\
        playMusic(music_gameover)\
\
    end\
\
    -- Reset scores.\
    player1_score, player2_score = 0, 0\
    player1_defeated_enemies = {lv1 = 0, lv2 = 0, lv3 = 0, lv4 = 0, bonus = 0}\
    player2_defeated_enemies = {lv1 = 0, lv2 = 0, lv3 = 0, lv4 = 0, bonus = 0}\
\
    os.sleep(2.5)\
\
    if not winned then\
        if total_score > hiscore then -- If player got a new high-score...\
            local function printHiscore ()\
                term.setCursorPos(1,17)\
                term.setBackgroundColor(colors.green)\
\
                for i = 1, resolution[1] / 2 + 1 do\
                    term.write(\"  \")\
                    os.sleep(0.02)\
\
                end\
\
                term.setCursorPos(screen_center[1] - 9, 17)\
                term.setTextColor(colors.white)\
                term.write(\"New Hi-Score:\")\
\
                for i = 1,100 do\
                    if i % 2 == 0 then term.setTextColor(colors.yellow)\
                    else term.setTextColor(colors.white)\
                    end\
\
                    term.setCursorPos(screen_center[1] + 4, 17)\
                    os.sleep(0.02)\
                    term.write(total_score)\
\
                end\
\
                term.setBackgroundColor(colors.black)\
            end\
\
            target_music = music_hiscore\
            parallel.waitForAll(playMusic_parallel, printHiscore)\
\
            hiscore = total_score\
\
            local file = fs.open(dir .. \"/Hiscore.txt\", \"w\")\
            file.write(hiscore)\
            file.close()\
\
        end\
\
        for i = 1, resolution[2] do\
            term.scroll(1)\
            os.sleep(0.05)\
\
        end\
\
    end\
\
end\
\
\
local function main_menu ()\
    while true do\
        term.setBackgroundColor(colors.black)\
        for i = 1, screen_center[2] + 1 do -- Clear the screen.\
            term.scroll(2)\
            os.sleep(0.05)\
\
        end\
        drawBackground()\
\
        term.setTextColor(colors.yellow)\
\
        term.setCursorPos(screen_center[1] - 5,3)\
        term.write(\"PIXEL TANK\")\
\
        term.setCursorPos(screen_center[1] - 9,4)\
        term.write(\"by Mr_Octopus_2020\")\
\
        term.setTextColor(colors.white)\
        term.setCursorPos(screen_center[1] - 6,6)\
        term.write(\"Hi Score:\" .. hiscore)\
\
        term.setBackgroundColor(colors.gray)\
        term.setTextColor(colors.lime)\
        term.setCursorPos(1, resolution[2])\
        term.write(\"Version \" .. version .. \" | \" .. env .. \" \" ..  string.rep(\"=\", resolution[1]))\
\
        local callback = menu({\
        {9,\"Singleplayer\"},\
        {11,\"Multiplayer\"},\
        {13,\"Edit Levels\"},\
        {15,\"Settings\"},\
        {17,\"Quit\"}\
        })\
\
        if callback == \"Singleplayer\" then\
            player1 = Tank(1, colors.yellow)\
\
            current_level = math.floor(settings.default_stage[1])\
            local result = readlevel(\"Level \" .. current_level .. \".map\")\
\
            while true do -- Skip the level if the level file is crashed.\
                if not result then\
                    current_level = current_level + 1\
                    if current_level > 15 then current_level = 1 end\
                    result = readlevel(\"Level \" .. current_level .. \".map\")\
\
                else break\
\
                end\
\
            end\
\
            switchscreen(\"Stage \" .. tostring(current_level))\
            os.sleep(0.5)\
\
            target_music = music_theme\
            parallel.waitForAll(playMusic_parallel,loadlevel)\
\
            player1:setPos(screen_center[1] - 2,17)\
            player1:setGodtime(40)\
            player1:show()\
\
            break\
\
        elseif callback == \"Multiplayer\" then\
            player1 = Tank(1, colors.yellow)\
            player2 = Tank(1, colors.lightBlue)\
\
            current_level = math.floor(settings.default_stage[1])\
            local result = readlevel(\"Level \" .. current_level .. \".map\")\
\
            while true do -- Skip the level if the level file is crashed.\
                if not result then\
                    current_level = current_level + 1\
                    if current_level > 15 then current_level = 1 end\
                    result = readlevel(\"Level \" .. current_level .. \".map\")\
\
                else break\
\
                end\
\
            end\
\
            switchscreen(\"Stage \" .. tostring(current_level))\
            os.sleep(0.5)\
\
            readlevel(\"Level \" .. current_level .. \".map\")\
\
            target_music = music_theme\
            parallel.waitForAll(playMusic_parallel,loadlevel)\
\
            player1:setPos(screen_center[1] - 2,17)\
            player1:setGodtime(40)\
            player1:show()\
            player2:setPos(screen_center[1] + 2,17)\
            player2:setGodtime(40)\
            player2:show()\
\
            break\
\
        elseif callback == \"Edit Levels\" then leveleditor()\
\
        elseif callback == \"Settings\" then SettingScreen()\
\
        else -- Quit game.\
            term.setBackgroundColor(colors.black)\
            origin_term.setBackgroundColor(colors.black)\
            for i = 1, screen_center[2] + 1 do -- Clear the screen.\
                term.scroll(2)\
                os.sleep(0.05)\
\
            end\
            drawBackground()\
\
            term.setTextColor(colors.yellow)\
            origin_term.clear()\
            origin_term.setCursorPos(1,1)\
            term.setCursorPos(1,1)\
            term.write(\"Thanks for playing Pixel Tank!\")\
\
            term = origin_term\
            os.queueEvent(\"remote_quit\")\
\
            print()\
            os.sleep(0.1)\
            error()\
\
        end\
\
    end\
end\
\
\
local function generateBonus () -- Randomly generate bonuses around the map.\
    local bonuses = {\"HP\", \"upgrade\", \"godtime\", \"bomb\", \"freeze\"}\
    local bonus\
    local index = math.random(1, 7)\
\
    if index <= 1 then bonus = bonuses[1]\
    elseif index <= 4 then bonus = bonuses[2]\
    elseif index <= 5 then bonus = bonuses[3]\
    elseif index <= 6 then bonus = bonuses[4]\
    elseif index <= 7 then bonus = bonuses[5]\
    end\
\
    local availables = {}\
\
    for y = 3, 17 do -- Find all the places that are suitable for generating. Enemy-spawning area not included.(y==2)\
        for x = screen_center[1] - 12, screen_center[1] + 12 do\
            local current = level[getLevelIndex(x,y)]\
\
            if current == 'air' and not checkCollison(x, y) then -- This place is suitable.\
                table.insert(availables, {x, y})\
\
            end\
        end\
    end\
\
    local position = availables[math.random(1, #availables)] -- Select one of all the available places.\
    level[getLevelIndex(position[1], position[2])] = bonus\
\
    term.setCursorPos(position[1], position[2])\
    term.setBackgroundColor(colors.gray)\
    if bonus == \"HP\" then\
        term.setTextColor(colors.yellow)\
        term.write(\"H\")\
\
    elseif bonus == \"upgrade\" then\
        term.setTextColor(colors.lime)\
        term.write(\"U\")\
\
    elseif bonus == \"godtime\" then\
        term.setTextColor(colors.white)\
        term.write(\"G\")\
\
    elseif bonus == \"bomb\" then\
        term.setTextColor(colors.orange)\
        term.write(\"B\")\
\
    elseif bonus == \"freeze\" then\
        term.setTextColor(colors.lightBlue)\
        term.write(\"F\")\
\
    end\
\
    playing_sound = music_spawnBonus\
\
end\
\
\
local function ai_event_handler ()\
    local spawn_points = {screen_center[1] - 12, screen_center[1] ,screen_center[1] + 12}\
    local last_spawn = 1\
    local pos\
\
    while true do\
\
        if not paused then\
            last_spawn = last_spawn + 1\
            if last_spawn > 3 then last_spawn = 1 end\
\
            pos = spawn_points[last_spawn] -- Randomly select a position to spawn enemy.\
\
            -- Wait until the pos is not occupied by other tank and there's enouth room to spawn new enemy.\
            repeat os.sleep(0.1) until not checkCollison(pos,2) and #ticking_enemies <= 3\
\
            if tonumber(enemies.lv1) > 0 then\
                spawnEnemy(1,pos)\
                enemies.lv1 = enemies.lv1 - 1\
                os.sleep(math.floor(settings.enemy_spawn_delay[1]))\
\
            elseif tonumber(enemies.lv2) > 0 then\
                spawnEnemy(2,pos)\
                enemies.lv2 = enemies.lv2 - 1\
                os.sleep(math.floor(settings.enemy_spawn_delay[1]))\
\
            elseif tonumber(enemies.lv3) > 0 then\
                spawnEnemy(3,pos)\
                enemies.lv3 = enemies.lv3 - 1\
                os.sleep(math.floor(settings.enemy_spawn_delay[1]))\
\
            elseif tonumber(enemies.lv4) > 0 then\
                spawnEnemy(4,pos)\
                enemies.lv4 = enemies.lv4 - 1\
                os.sleep(math.floor(settings.enemy_spawn_delay[1]))\
\
            else\
                if #ticking_enemies == 0 then -- If all the enemies defeated...\
                    winned = true\
                    os.sleep(3)\
                    break\
\
                end\
\
            end\
\
        else os.sleep(0.05)\
\
        end\
\
    end\
end\
\
\
local function hit_event_handler () -- Handle events when tanks are being hit.\
    local removing_index = {} -- Tanks that will be moved to \"deprecated_enemies\" will mark its index in \"ticking_enemies\" here.\
\
    while true do\
        local event, target, defeater, position = os.pullEvent(\"hit\") -- Defeater is the player who defeated this target.\
\
        if target == 'player1' and not player1:isGodtime() then player1:removeHP(1) -- Hit player1\
        elseif target == 'player2' and not player2:isGodtime() then player2:removeHP(1) -- Hit player2\
        elseif type(target) == \"number\" then -- Hit enemy.\
            ticking_enemies[target]:removeHP(1)\
\
            local current = ticking_enemies[target]\
            local current_model = current:getModel()\
            local current_HP = current:getHP()\
\
            if current_HP <= 0 then\
                current:kill()\
                if math.random(1, 20) <= settings.bonus_chance[1] then generateBonus() end  -- Get a bonus when defeat an enemy.\
\
                local target_score -- Specifies how much score does the tank worth.\
                if current_model == 1 then target_score = 100\
                elseif current_model == 2 then target_score = 200\
                elseif current_model == 3 then target_score = 250\
                elseif current_model == 4 then target_score = 400\
                end\
\
                if defeater == \"player1\" then\
                    player1_score = player1_score + target_score\
\
                    if current_model == 1 then player1_defeated_enemies.lv1 = player1_defeated_enemies.lv1 + 1\
                    elseif current_model == 2 then player1_defeated_enemies.lv2 = player1_defeated_enemies.lv2 + 1\
                    elseif current_model == 3 then player1_defeated_enemies.lv3 = player1_defeated_enemies.lv3 + 1\
                    elseif current_model == 4 then player1_defeated_enemies.lv4 = player1_defeated_enemies.lv4 + 1\
                    end\
\
                elseif defeater == \"player2\" then\
                    player2_score = player2_score + target_score\
\
                    if current_model == 1 then player2_defeated_enemies.lv1 = player2_defeated_enemies.lv1 + 1\
                    elseif current_model == 2 then player2_defeated_enemies.lv2 = player2_defeated_enemies.lv2 + 1\
                    elseif current_model == 3 then player2_defeated_enemies.lv3 = player2_defeated_enemies.lv3 + 1\
                    elseif current_model == 4 then player2_defeated_enemies.lv4 = player2_defeated_enemies.lv4 + 1\
                    end\
\
                end\
\
                table.insert(deprecated_enemies, current)\
                table.insert(removing_index, target)\
\
            end\
\
        elseif target == \"base\" then -- Hit base: GAME OVER.\
            term.setTextColor(colors.white)\
            term.setBackgroundColor(colors.red)\
            term.setCursorPos(screen_center[1], 17)\
            term.write(\"x\")\
\
            playSoundEffect(sound_baseHit)\
\
            winned = false\
            break\
\
        elseif (target == \"HP\" or target == \"upgrade\" or target == \"godtime\" or target == \"bomb\" or target == \"freeze\")\
        and (defeater == \"player1\" or defeater == \"player2\")\
        then -- Eat bonuses.\
            playSoundEffect(sound_experience)\
\
            if target == \"HP\" then\
                player1_HP = player1_HP + 1\
                if player2 then player2_HP = player2_HP + 1 end\
\
                playing_sound = music_eatBonusPlus\
\
            elseif target == \"upgrade\" then\
                if defeater == \"player1\" then player1:upgrade()\
                elseif defeater == \"player2\" then player2:upgrade()\
                end\
\
                playing_sound = music_eatBonus\
\
            elseif target == \"godtime\" then\
                if defeater == \"player1\" then player1:setGodtime(250)\
                elseif defeater == \"player2\" then player2:setGodtime(250)\
                end\
\
                playing_sound = music_eatBonus\
\
            elseif target == \"bomb\" then\
                for i = 1, #ticking_enemies do\
                    local current = ticking_enemies[i]\
\
                    current:kill()\
                    table.insert(deprecated_enemies, current)\
\
                    speaker.playNote(\"basedrum\", settings.volume[1], 16)\
                    speaker.playNote(\"basedrum\", settings.volume[1], 16)\
\
                end\
                ticking_enemies = {}\
\
                playing_sound = music_eatBonus\
\
            elseif target == \"freeze\" then\
                freezing = 250\
                playing_sound = music_eatBonus\
\
            end\
\
            if defeater == \"player1\" then\
                player1_score = player1_score + 500\
                player1_defeated_enemies.bonus = player1_defeated_enemies.bonus + 1\
\
            elseif defeater == \"player2\" then\
                player2_score = player2_score + 500\
                player2_defeated_enemies.bonus = player2_defeated_enemies.bonus + 1\
\
            end\
\
            level[getLevelIndex(position[1], position[2])] = \"air\" -- Remove this bonus.\
\
            term.setBackgroundColor(colors.black)\
            term.setCursorPos(position[1], position[2])\
            term.write(\" \")\
\
        end\
\
        if player1:getHP() <= 0 then player1:kill() end -- Check if P1 is dead.\
\
        if player2 then\
            if player2:getHP() <= 0 then player2:kill() end -- Check if P2 is dead.\
\
        end\
\
        for i = 1, #removing_index do -- Remove the marked tanks from \"ticking_enemies\".\
            table.remove(ticking_enemies, removing_index[i])\
\
        end\
\
        removing_index = {} -- Reset the \"removing\" marks.\
\
        os.sleep(0.05)\
    end\
end\
\
\
local function reborn_handler () -- Reborn player's tank.\
    while true do\
        if not paused then\
            if player1_HP > 0 and not player1:isSurvive() then -- If P1 is dead and has HP remains...\
                os.sleep(1.5)\
\
                for i = 1,10 do -- Play animation.\
                    term.setBackgroundColor(colors.gray)\
                    term.setTextColor(colors.white)\
                    term.setCursorPos(screen_center[1] - 2,17)\
\
                    if i % 2 == 0 then term.write(\"x\")\
                    else term.write(\"+\")\
                    end\
\
                    os.sleep(0.1)\
                end\
\
                player1:born(screen_center[1] - 2, 17,  1, 40)\
                player1_HP = player1_HP - 1\
\
            end\
\
            if player2 then\
                if player2_HP > 0 and not player2:isSurvive() then -- If P2 is dead and has HP remains...\
                    os.sleep(1)\
\
                    for i = 1,10 do\
                        term.setBackgroundColor(colors.gray)\
                        term.setTextColor(colors.white)\
                        term.setCursorPos(screen_center[1] + 2,17)\
\
                        if i % 2 == 0 then term.write(\"x\")\
                        else term.write(\"+\")\
                        end\
\
                        os.sleep(0.1)\
                    end\
\
                    player2:born(screen_center[1] + 2, 17, 1, 40)\
                    player2_HP = player2_HP - 1\
\
                end\
            end\
\
            -- Is it over? Game over when both players are defeated and no more HP remains.\
            if player2 then\
                if player1_HP == 0 and player2_HP == 0 and not player1:isSurvive() and not player2:isSurvive() then\
                    winned = false\
                    os.sleep(1)\
                    break\
\
                end\
\
            else\
                if player1_HP == 0 and not player1:isSurvive() then\
                    winned = false\
                    os.sleep(1)\
                    break\
\
                end\
\
            end\
\
        end\
\
        os.sleep(0.5)\
    end\
end\
\
\
\
-- ======================== MAIN ========================\
\
-- Ask players their way to play.\
term.clear()\
drawBackground()\
\
term.setTextColor(colors.yellow)\
term.setBackgroundColor(colors.gray)\
\
for i = 1, screen_center[2] do -- Split an gray area.\
    term.setCursorPos(1, i)\
    term.write(string.rep(\" \", resolution[1]))\
\
    os.sleep(0.05)\
end\
\
term.setCursorPos(screen_center[1] - 11, screen_center[2] - 5)\
term.write(\"Welcome to Pixel Tank!\")\
\
term.setCursorPos(screen_center[1] - 12, screen_center[2] - 3)\
term.write(\"How do you want to play?\")\
\
local callback = menu({\
    {screen_center[2] + 3, \"Play on this device\"},\
    {screen_center[2] + 5, \"Play on monitors using joystick\"},\
    {screen_center[2] + 7, \"Quit\"}\
})\
\
if callback == \"Play on monitors using joystick\" then -- Play on attached computers using remote.\
    term.setBackgroundColor(colors.black)\
    for i = 1, screen_center[2] + 1 do -- Clear the screen.\
        term.scroll(2)\
        os.sleep(0.05)\
\
    end\
\
    drawBackground()\
\
    local monitor = peripheral.find(\"monitor\") -- Find a monitor.\
\
    if not monitor then -- Failed to find any monitors.\
        term.setTextColor(colors.orange)\
        term.setCursorPos(screen_center[1] - 19, screen_center[2] - 4)\
        term.write(\"Sorry, but we can't find any monitors.\")\
\
        term.setTextColor(colors.white)\
        term.setCursorPos(screen_center[1] - 17, screen_center[2] - 3)\
        term.write(\"The game will start in 3 seconds.\")\
\
        os.sleep(3)\
\
    else\
        local origin_resolution = resolution\
        local origin_screen_center = screen_center\
\
        term = monitor -- Redirect terminal to monitor.\
        resolution = {term.getSize()} -- Reset resolutions.\
        screen_center = {\
            math.floor(resolution[1] / 2),\
            math.floor(resolution[2] / 2)\
        }\
\
        origin_term.setCursorPos(1,1)\
        if resolution[1] < 25 then error(\"This game requires a monitor that widths at least 25 pixels!\", 0)\
        elseif resolution[2] < 19 then error(\"This game requires a monitor that heights at leat 19 pixels!\", 0)\
        end\
\
        if resolution[1] < 50 then\
            origin_term.setTextColor(colors.orange)\
            origin_term.setCursorPos(origin_screen_center[1] - 20, 2)\
            origin_term.write(\"Warning: this game might be not enjoyable\")\
            origin_term.setCursorPos(origin_screen_center[1] - 20, 4)\
            origin_term.write(\"with a monitor that widths less than 50.\")\
\
        end\
\
        origin_term.setTextColor(colors.lime)\
        origin_term.setCursorPos(origin_screen_center[1] - 19, origin_screen_center[2] - 2)\
        origin_term.write(\"Your game will start on remote mode.\")\
        origin_term.setTextColor(colors.white)\
        origin_term.setCursorPos(origin_screen_center[1] - 18, origin_screen_center[2])\
        origin_term.write(\"The game will start after 3 seconds.\")\
\
        os.sleep(3)\
\
        term.setCursorBlink(false)\
        shell.openTab(\"remote.lua\")\
\
    end\
\
elseif callback == \"Quit\" then\
    term.setTextColor(colors.yellow)\
    term.setBackgroundColor(colors.black)\
\
    for i = 1, screen_center[2] + 1 do -- Clear the screen.\
        term.scroll(2)\
        os.sleep(0.05)\
\
    end\
\
    term.setCursorPos(1,1)\
    term.setCursorPos(1,1)\
    term.write(\"Thanks for playing Pixel Tank!\")\
\
    os.queueEvent(\"remote_quit\")\
\
    print()\
    os.sleep(0.1)\
    error()\
\
end\
\
main_menu()\
\
local function mainloop ()\
    while true do\
        time = time + 0.001\
\
        if enter_pressed then\
            if paused then\
                paused = false\
\
                term.setBackgroundColor(colors.gray)\
                term.setCursorPos(1,1)\
                term.write(string.rep(\" \", resolution[1]))\
\
                os.sleep(0.4)\
\
            else\
                paused = true\
\
                term.setTextColor(colors.white)\
                term.setBackgroundColor(colors.red)\
                term.setCursorPos(1,1)\
                term.write(\"PAUSED. Press ENTER to resume or Shift to quit.\")\
\
                playMusic(music_pause)\
\
            end\
\
        end\
\
        if not paused then -- Only do mainloop when game is not in pause.\
\
            player1:tickGodtime()\
\
            if w_pressed and not s_pressed then player1:move('up') -- player1 actions.\
            elseif s_pressed and not w_pressed then player1:move('down')\
            elseif a_pressed and not d_pressed then player1:move('left')\
            elseif d_pressed and not a_pressed then player1:move('right')\
            end\
            player1_pos = {player1:getPos()} -- Update positions.\
\
            if player2 then  -- player2 actions.\
                player2:tickGodtime()\
\
                if up_pressed and not down_pressed then player2:move('up')\
                elseif down_pressed and not up_pressed then player2:move('down')\
                elseif left_pressed and not right_pressed then player2:move('left')\
                elseif right_pressed and not left_pressed then player2:move('right')\
                end\
                player2_pos = {player2:getPos()}\
\
            end\
\
            -- Tick bullets from player tank.\
            player1:tickBullets()\
            if player2 then player2:tickBullets() end\
\
            if space_pressed then player1:fire('player1') end -- Firing control.\
            if player2 and e_pressed then player2:fire('player2') end\
\
            -- Tick bullets from dead tank.\
            local removing_index = {} -- Containing all the tank indexes that will be totally removed.\
\
            for i = 1, #deprecated_but_ticking_enemies do\
                local current = deprecated_but_ticking_enemies[i]\
                current:tickBullets()\
\
                -- Mark the tank as totally deprecated if it has no more bullets to tick.\
                if not current:stillBulletsTicking() then table.insert(removing_index, i) end\
\
            end\
\
            -- Clean up.\
            for i = 1, #removing_index do table.remove(deprecated_but_ticking_enemies, removing_index[i]) end\
\
            -- Freezing countdown.\
            if freezing > 0  then freezing = freezing - 1 end\
\
            -- Tick enemies.\
            for i = 1, #ticking_enemies do\
                ticking_enemies[i]:tick()\
\
            end\
\
            -- Remove dead enemies.\
            for i = 1, #deprecated_enemies do\
                local current = deprecated_enemies[i]\
\
                if current:stillBulletsTicking() then\
                    --  Don't remove it right now. Transfer the dead tank from \"ticking_enemies\" to \"deprecated_enemies\".\
                    table.insert(deprecated_but_ticking_enemies, current)\
\
                end\
\
            end\
\
            deprecated_enemies = {}\
\
            -- Play animation and spawn enemies.\
            if #spawning_enemies > 0 then\
                local current = spawning_enemies[1]\
                spawning_pos = {current[3], 2}\
\
                current[2] = current[2] - 1 -- Countdown.\
\
                term.setTextColor(colors.white)\
                term.setBackgroundColor(colors.gray)\
                term.setCursorPos(spawning_pos[1], spawning_pos[2])\
                if current[2] % 5 <= 2 then term.write(\"+\")\
                else term.write(\"x\")\
                end\
\
                if current[2] <= 0 then\
                    current[1]:setPos(current[3],2)\
                    current[1]:show()\
                    table.insert(ticking_enemies, current[1])\
                    table.remove(spawning_enemies, 1)\
                    spawning_pos = {0, 0}\
\
                end\
\
            end\
\
            -- Print game data like health and stage etc.\
            term.setBackgroundColor(colors.blue)\
            term.setTextColor(colors.white)\
            term.setCursorPos(1, resolution[2])\
            term.write(string.rep(\" \",51))\
\
            term.setCursorPos(1, resolution[2])\
            term.write(\"Stage:\")\
            term.write(tostring(current_level))\
\
            term.setCursorPos(resolution[1] - 11, resolution[2])\
            term.write(\"Enemies:\")\
            term.write(tostring(enemies.lv1 + enemies.lv2 + enemies.lv3 + enemies.lv4))\
\
            term.setBackgroundColor(colors.lightGray)\
            term.setCursorPos(1, resolution[2] - 1)\
            term.write(string.rep(\" \",51))\
\
            term.setCursorPos(1, resolution[2] - 1)\
            term.write(\"Player1 HP:\")\
            term.write(player1_HP)\
\
            if player2 then\
                term.setCursorPos(resolution[1] - 12, resolution[2] - 1)\
                term.write(\"Player2 HP:\")\
                term.write(player2_HP)\
\
            end\
\
            if resolution[1] >= 50 then\
                term.setTextColor(colors.white)\
                term.setBackgroundColor(colors.black)\
\
                for y = 2,6 do\
                    term.setCursorPos(resolution[1] - 11, y)\
                    term.write(string.rep(\" \",11))\
\
                end\
                term.setCursorPos(resolution[1] - 10, 3)\
                term.write(\"I \" .. player1_score)\
\
                if player2 then\
                    term.setCursorPos(resolution[1] - 11,5)\
                    term.write(\"II \" .. player2_score)\
\
                end\
            end\
\
            term.setBackgroundColor(colors.gray)\
            term.setTextColor(colors.lightGray)\
            term.setCursorPos(1,1)\
            term.write(\" \")\
\
            os.sleep(0.05)\
\
        else\
            os.sleep(0.1)\
\
        end\
\
    end\
\
end\
\
\
\
while true do\
    parallel.waitForAny(\
        keyboard_event_handler,\
        hit_event_handler,\
        mainloop,\
        ai_event_handler,\
        reborn_handler,\
        sound_Handler\
    )\
\
    if winned then\
        gameover()\
\
        -- Re-initialize the game.\
        w_pressed,\
        a_pressed,\
        s_pressed,\
        d_pressed,\
        space_pressed,\
        up_pressed,\
        down_pressed,\
        left_pressed,\
        right_pressed,\
        e_pressed,\
        enter_pressed\
        = false, false, false, false, false, false, false, false, false, false, false\
\
        paused = false\
        winned = false\
\
        freezing = 0\
\
        spawning_enemies,\
        ticking_enemies,\
        deprecated_enemies,\
        deprecated_but_ticking_enemies\
        = {}, {}, {}, {}\
\
        current_level = current_level + 1\
        if current_level > 15 then current_level = 1 end\
\
        local result = readlevel(\"Level \" .. current_level .. \".map\")\
\
        while true do -- Skip the level if the level file is crashed.\
            if not result then\
                current_level = current_level + 1\
                if current_level > 15 then current_level = 1 end\
                result = readlevel(\"Level \" .. current_level .. \".map\")\
\
            else break\
\
            end\
\
        end\
\
        switchscreen(\"Stage \" .. tostring(current_level))\
        os.sleep(0.5)\
\
        readlevel(\"Level \" .. current_level .. \".map\")\
\
        target_music = music_theme\
        parallel.waitForAll(playMusic_parallel,loadlevel)\
\
        player1:clearBullets()\
        if player1:isSurvive() then\
            player1:setPos(screen_center[1] - 2,17)\
            player1:show()\
\
        end\
\
        if player2 then\
            player2:clearBullets()\
            if player2:isSurvive() then\
                player2:setPos(screen_center[1] + 2,17)\
                player2:show()\
\
            end\
\
        end\
\
    else\
        os.sleep(2)\
        gameover()\
\
        -- Re-initialize the game.\
        w_pressed,\
        a_pressed,\
        s_pressed,\
        d_pressed,\
        space_pressed,\
        up_pressed,\
        down_pressed,\
        left_pressed,\
        right_pressed,\
        e_pressed,\
        enter_pressed\
        = false, false, false, false, false, false, false, false, false, false, false\
\
        winned = false\
        paused = false\
\
        freezing = 0\
\
        spawning_pos = {0, 0} -- Position that is going to spawn a tank.\
        player1_pos, player2_pos = {}, {} -- Player tank's position. Used by function checkCollison().\
        player1_HP, player2_HP = math.floor(settings.default_HP[1]), math.floor(settings.default_HP[1])\
        player1_score, player2_score = 0, 0\
        total_score = 0\
\
        spawning_enemies,\
        ticking_enemies,\
        deprecated_enemies,\
        deprecated_but_ticking_enemies\
        = {}, {}, {}, {}\
\
\
        main_menu()\
    end\
\
end",
  },
  name = "pixel_tank",
  aliases = {{"tank","tank.lua"}},
}
